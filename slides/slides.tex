\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{naturalnames}{hyperref}
\PassOptionsToPackage{table}{xcolor}

\documentclass[14pt]{beamer}

\mode<presentation> {

% The Beamer class comes with a number of default slide themes
% which change the colors and layouts of slides. Below this is a list
% of all the themes, uncomment each in turn to see what they look like.

%\usetheme{default}
%\usetheme{AnnArbor}
%\usetheme{Antibes}
%\usetheme{Bergen}
%\usetheme{Berkeley}
%\usetheme{Berlin}
%\usetheme{Boadilla}
%\usetheme{CambridgeUS}
%\usetheme{Copenhagen}
%\usetheme{Darmstadt}
%\usetheme{Dresden}
%\usetheme{Frankfurt}
%\usetheme{Goettingen}
%\usetheme{Hannover}
%\usetheme{Ilmenau}
%\usetheme{JuanLesPins}
%\usetheme{Luebeck}
%\usetheme{Madrid}
%\usetheme{Malmoe}
%\usetheme{Marburg}
%\usetheme{Montpellier}
%\usetheme{PaloAlto}
%\usetheme{Pittsburgh}
%\usetheme{Rochester}
%\usetheme{Singapore}
%\usetheme{Szeged}
%\usetheme{Warsaw}

% As well as themes, the Beamer class has a number of color themes
% for any slide theme. Uncomment each of these in turn to see how it
% changes the colors of your current slide theme.

%\usecolortheme{albatross}
%\usecolortheme{beaver}
%\usecolortheme{beetle}
%\usecolortheme{crane}
%\usecolortheme{dolphin}
%\usecolortheme{dove}
%\usecolortheme{fly}
%\usecolortheme{lily}
%\usecolortheme{orchid}
%\usecolortheme{rose}
%\usecolortheme{seagull}
%\usecolortheme{seahorse}
%\usecolortheme{whale}
%\usecolortheme{wolverine}

%\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line
%\setbeamertemplate{footline}[page number] % To replace the footer line in all slides with a simple slide count uncomment this line

\setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
\setbeamertemplate{frametitle continuation}[from second][(\insertcontinuationcountroman)]
}

\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables
%\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{tikz}
\usepackage{forest}
\usetikzlibrary{calc,math,shapes.callouts,shapes.arrows,shapes.geometric,fit,positioning,arrows.meta}
\usetikzlibrary{positioning,backgrounds}
\usetikzlibrary{decorations.pathmorphing,math}
%\usepackage{iwona}
%\usepackage{marvosym}
%\usepackage{cfr-lm}
%\usepackage{pifont}
%\usepackage{keystroke}
%\usepackage{etoolbox}

% Language Definitions for CYPHER
\lstdefinelanguage{cypher}{
morecomment=[l][\color{gray}]{//},
morestring=[b][\color{olive}]\",
morestring=[b][\color{olive}]\',
morekeywords={MATCH,WHERE,LIMIT,CREATE,RETURN,DISTINCT,DELETE,DETACH,UNIQUE,MERGE,INDEX,ON,SET,LOAD,CSV,FOREACH,IN},
sensitive=true
}

%
% Listados de código
%
\lstset{%
basicstyle=\ttfamily\footnotesize,
commentstyle=\color{gray}\itshape\ttfamily,
keywordstyle=\color{blue!80}\bfseries\ttfamily,
stringstyle = \color{gray},
showstringspaces=false,
frame=tblr, % single, tb, ltrb % boxed listings, en mayusculas = doble linea
framerule=0pt,
tabsize=4, % tabulador = 2 espacios
captionpos=b,
backgroundcolor=\color{yellow!20},
breaklines=true,
%backgroundcolor=\color{white},
%numbers=left, numberstyle=\tiny, stepnumber=2, numbersep=10pt,
xleftmargin=0.02\textwidth,
xrightmargin=0.02\textwidth,
mathescape=false,
language=java, % Por defecto
literate={«}{{\guillemotleft}}1
           {»}{{\guillemotright}}1
{á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1
           {ñ}{{\~n}}1
           {Ñ}{{\~N}}1
           {¿}{{?`}}1
}

\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{numb}{magenta!60!black}

\lstdefinelanguage{json}{
    basicstyle=\ttfamily,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
%    frame=lines,
    moredelim=**[is][\color{red}]{@}{@},
    moredelim=**[is][\color{blue}]{º}{º},
%    backgroundcolor=\color{background},
    literate=
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1}
}

\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}
{
  basicstyle=\ttfamily,
  keywords={typeof,new,true,false,catch,function,return,null,catch,switch,var,if,in,while,do,else,case
,break},
ndkeywords={class, export, boolean, throw, implements, import, this},
ndkeywordstyle=\color{darkgray}\bfseries,
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
morestring=[b]',
morestring=[b]"
}

%% Macros comunes
\newcommand{\hide}[1]{}
\newcommand{\ra}{{\color{blue} $\Rightarrow${}~{}}}

\usepackage{fontspec}
\defaultfontfeatures{Ligatures=TeX,Numbers=OldStyle}
% \setmainfont{Aller_Lt.ttf}[
% BoldFont = Aller_Rg.ttf,
% ItalicFont = Aller_LtIt.ttf,
% BoldItalicFont = Aller_It.ttf]
\setsansfont
  [Ligatures=TeX, % recommended
   UprightFont={* Light},
   ItalicFont={* Light Italic},
   BoldFont={*},
   BoldItalicFont={* Italic}]
  {Open Sans}
% \setsansfont
%   [Ligatures=TeX, % recommended
%    UprightFont={* Regular},
%    ItalicFont={* Italic}]
%   {Fira Sans}
%\setmainfont{Open Sans}[BoldFont={* Bold}]
% \setmonofont[Ligatures = TeX,
% UprightFont={* Light},
%    ItalicFont={* Light Italic},
%    BoldFont={* Medium},
%    BoldItalicFont={* Medium Italic}]{Input Mono}

%\setmonofont{Input Mono}
\setmonofont%[Scale=1.1]
  [Ligatures=TeX, % recommended
%   UprightFont={* Regular},
%   ItalicFont={* Italic},
%   BoldFont={* Bold},
%   BoldItalicFont={* Bold Italic}
   ]
{Fira Mono}

\setbeamercolor{block title}{bg=blue!30,fg=black}
\setbeamercolor{block body}{bg=blue!20,fg=black}
\setbeamercolor{block title alerted}{bg=red!30,fg=black}
\setbeamercolor{block body alerted}{bg=red!20,fg=black}

\newsavebox{\mysubpic}

\usebackgroundtemplate{
%\setbox{\mysubpic}{
  \sbox{\mysubpic}{%
    \begin{tikzpicture}[remember picture,line width=1em,blue!30] %sub-picture
      \foreach \s in {1,...,\value{framenumber}}{
        \tikzmath{
          int \shift;
          \shift = (\s * 2);
          if Mod(\s,5) > 0 then {
            { \draw[xshift=\shift em] (0,0) -- (0,5em); };
          } else {
            { \draw[xshift=\shift em] (-.5em,3em) -- (-9.5em,1em); };
          };
       }
      }
    \end{tikzpicture}% needed, otherwise anchors are wrong!
  }

  \begin{tikzpicture}[remember picture,overlay,line width=2em]
    %\node[opacity=0.3, at=(current page.south east),anchor=south east,inner sep=0pt] {
%    \includegraphics[height=\paperheight,width=\paperwidth]{image}};
    \coordinate[at=(current page.north west)] (ul);
    \coordinate[at=(current page.south west)] (sw);
    \coordinate[at=(current page.south east)] (lr);
%    \path (ul) -- (lr) node[opacity=0.3,midway,anchor=center]{\usebox{\mysubpic}};
    \path (sw) -- (lr) node[opacity=.7,pos=.99,anchor=south east,scale=.1]{\usebox{\mysubpic}};
  \end{tikzpicture}
}

\hypersetup{%
  pdftitle={Bases de Datos NoSQL},%
  pdfauthor={Jesús García Molina, Diego Sevilla Ruiz},
  pdfsubject={NoSQL, CENTIC'18},
  pdfkeywords={nosql, centic18}
}


%----------------------------------------------------------------------------------------
%       TITLE PAGE
%----------------------------------------------------------------------------------------

\title{Bases de datos
  NoSQL\thanks{\url{https://github.com/dsevilla/centic18}}}
\subtitle{CENTIC, 2018}

\author{Jesús García Molina, Diego Sevilla Ruiz}
\institute[UMU]
{
Facultad de Informática\\
Universidad de Murcia\\
\medskip
\href{mailto:dsevilla@um.es}{\texttt{\{jmolina,dsevilla\}@um.es}}
}
\date{Junio de 2018}

\makeatletter
\patchcmd{\beamer@sectionintoc}{\vskip1.5em}{\vskip1em}{}{}
\makeatother

\begin{document}

%\def\insertsectionnumber{\arabic{section}}

% \AtBeginSection[]{

% \begin{frame}[plain]

%   \begin{centering}
%     \begin{beamercolorbox}[sep=10pt,center]{part title}
%       {\huge \bf \textcolor{white}{\insertsectionnumber.~\insertsection}}
%     \end{beamercolorbox}
%   \end{centering}

%   \end{frame}
% }

%\def\insertsubsectionnumber{\arabic{subsection}}

% \AtBeginSection[]{
%   \begin{frame}<beamer>
%     \frametitle{\insertsubsection}

%     \tableofcontents[currentsection]
%   \end{frame}
% }
% \AtBeginSubsection[]{
%   \begin{frame}<beamer>
%     \frametitle{\insertsubsection}

%     \tableofcontents[currentsection,currentsubsection]
%   \end{frame}
% }

{
  \usebackgroundtemplate{%
    \vbox to \paperheight{\vfil\includegraphics[width=\paperwidth]{img/centic}\vfil}}
\begin{frame}
\titlepage % Print the title page as the first slide
\end{frame}
}
%\section{Introducción}

% \begin{frame}
% \frametitle{Índice}
% \tableofcontents[]
% \end{frame}


% \subsection{Un inciso}

% \begin{frame}[fragile,allowframebreaks]
%   \frametitle{Pero antes, un inciso}
%   \begin{itemize}
%   \item Imaginemos que quiero hacer una BBDD de estas diapositivas
%   \item Imaginemos que uso NoSQL:
% \begin{lstlisting}[language=bash]
% $ docker pull mongo
% $ docker run --rm -d --name mongo -p 27017:27017 mongo
% \end{lstlisting}
%   \item Imaginemos que uso Python

%     \framebreak

%   \item Quiero crear la base de datos ``{\tt presentations}'' y la colección
%     ``{\tt jisbd17}''
% \begin{lstlisting}[language=python]
% import pymongo
% from pymongo import MongoClient
% client = MongoClient("localhost", 27017)
% \end{lstlisting}

% \begin{lstlisting}[language=python]
% db = client.presentations
% jisbd17 = db.jisbd17  # colección jisbd17
% \end{lstlisting}

%     \framebreak

% \item Datos para una diapositiva:

% \begin{lstlisting}[language=python]
% jisbd17.insert_one(
%   {'_id': 'jisbd17-000',
%    'title': 'blah',
%    'text' : '',
%    'image': None,
%    'references':
%         [{'type': 'web',
%           'ref': 'http://nosql-database.org'},
%          {'type' : 'book',
%           'ref': 'Sadalage, Fowler. NoSQL Distilled, 2009'}
%         ],
%    'xref': ['jisbd17-010', 'jisbd17-002'],
%    'notes': 'blah blah'
%   })
% \end{lstlisting}

% \framebreak

% \item ¡Las imágenes!

% \begin{lstlisting}[language=python]
% import os
% import glob
% files = glob.glob('slides/slides-dir/*.png')
% for file in files:
%     img = load_img(file)
%     img_to_thumbnail(img)
%     slidename = os.path.basename(
%                   os.path.splitext(file)[0])
%     jisbd17.update_one(
%               {'_id': slidename},
%               {'$set' : {'image': img_to_bytebuffer(img)}},
%               True)
% \end{lstlisting}

%   \framebreak

% \item Se añaden características a los {\em slides}
% \item En el segundo bucle se {\bf actualiza} {\tt image}
% \end{itemize}

% \begin{alertblock}{¿Y el modelado de datos?}
% \end{alertblock}

% \framebreak

% \centering\includegraphics[width=.9\textwidth]{img/slides-data-model}

% \framebreak

% \begin{itemize}
% \item OK, pensemos en {\bf relacional}
%   \begin{itemize}
%   \item \lstinline[language=sql]{CREATE TABLE ...}
%   \item ¿Cuántas tablas?
%   \item Claves ajenas, restricciones de integridad...
%   \item {\bf Gap semántico}:
%     \begin{itemize}
%     \item La tabla {\tt Reference} no está contenida {\bf sino enlazada}
%       (por clave ajena)
%     \item O bien se crea la tabla {\tt Slide\_Reference}
%     \item {\bf ID Artificial} para referencias
%     \item Se tiene que crear la tabla {\tt Slide\_xref}
%     \end{itemize}
%   \end{itemize}

% \end{itemize}

% \begin{block}{El modelo de documentos es {\bf más natural en este caso}}
% \end{block}

% \framebreak

% \begin{alertblock}{¿Y toda la información de diapositiva?}
% \begin{itemize}
% \begin{lstlisting}[language=sql]
% SELECT * FROM Slides WHERE `_id` = 'jisbd17-000';
% \end{lstlisting}
%   \item ¿{\tt xref}? ¿{\tt references}?
% \begin{lstlisting}[language=sql]
% SELECT * FROM Slides s
%   JOIN References r ON `s._id` = r.slide_id
%   JOIN Slide_xref x ON `s._id` = x.slide_id
% WHERE `s._id` = 'jisbd17-000';
% \end{lstlisting}
% \item Filas con {\bf ¡¡información replicada!!}
% \item ¿Y si se añade más información a {\tt Slide}?
%   \end{itemize}
% \end{alertblock}

% \framebreak

% \begin{block}{MongoDB}
% \begin{lstlisting}[language=Python]
% slide = jisbd17.find_one({'_id': 'jisbd17-000'})
% \end{lstlisting}
% \end{block}

% \end{frame}

\section{Introducción a los sistemas NoSQL}

\input nosql

\section{Tipos de Sistemas NoSQL}

\subsection{Key-Value Stores}

\begin{frame}[fragile,fragile,allowframebreaks]
  \frametitle{Key/Value Stores}
\begin{itemize}
\item A cada pieza de datos se le asigna un identificador
\item Como valor se almacena cualquier conjunto de información
\item El caso de uso estándar es:
  \begin{itemize}
  \item {\bf Cachés de acceso} a partes de programas
  \item Por ejemplo, los iconos de los usuarios de una página, iconos de
    productos, etc.
  \end{itemize}
\item Key-Value: {\bf Riak}, {\bf Redis}, {\bf Memcached}, {\bf LevelDB},
  {\bf Amazon Dynamo}
\end{itemize}

\framebreak

\begin{lstlisting}[language=ruby,morekeywords=define]
define getCustomer(p_customerID):
  begin
    if exists(customerCache[p_customerID])
      return(customerCache[p_customerID])
    else
      return(addQueryResultsToCache(p_customerID,
             'SELECT * FROM customers
              WHERE customerID = p_CustomerID'))
    end
  end
\end{lstlisting}

(de {\bfseries\itshape NoSQL for Mere Mortals}, Dan Sullivan,
Addison-Wesley, 2015)
\end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{Bases de Datos Documentales}
\vspace*{-.9em}
\begin{itemize}
\item A cada pieza de datos se le asigna un identificador
\item La diferencia entre las key/value
  \begin{itemize}
  \item En {\bf Key/Value}, el valor es opaco (es un {\em blob\/})
  \item En las documentales, la base de datos puede ver el contenido del
    agregado, y utilizar su información como parte de las búsquedas y
    actualizaciones
\end{itemize}
\item Documentos $\Rightarrow$ formatos jerárquicos tipo JSON o XML
\framebreak
\item La diferencia entre ambas un poco difusa
  \begin{itemize}
  \item Por ejemplo, Riak es Key-Value pero permite realizar búsquedas
    indexadas parecidas a las de Solr/Lucene
\item Redis permite que los valores de datos sean estructurados en arrays,
  estructuras, mapas
  \end{itemize}
\item {\bf CouchDB}, {\bf MongoDB}, {\bf OrientDB} (también soporta grafos)
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Bases de Datos Documentales}
  \includegraphics[width=\textwidth]{img/MongoDB}
\end{frame}


% \begin{frame}[fragile]
%   \vspace{-0.65cm}
%   \begin{columns}
%     \column[t]{.5\textwidth}
%     \begin{lstlisting}[language=json,basicstyle=\tiny\tt]
% { "type": "Movie",
%   "title": "Citizen Kane",
%   "year": 1941,
%   "director_id": "123451",
%   "genre": "Drama",
%   "_id": "1",
%   "rating":
%   { "score": 8.4,
%     "voters": 310768
%   },
%   "prizes": [
%     { "year": 1941,
%       "event": "Oscar",
%       "names": ["Best original screenplay"]
%     },
%     { "year": 1941,
%       "event": "NY Film Critics",
%       "names": ["Best screenplay"]
%     }
%   ],
%   "criticisms": [
%     { "journalist": "R. Brody",
%       "media": "The New Yorker",
%       "color": "green"
%     }
%   ]
% },
% { "_id": "123451",
%   "name": "Orson Welles",
%   "type": "director",
%   "directed_movies": ["1"],
%   "acted_movies": ["1"]
% },
%     \end{lstlisting}
%     \column[t]{.5\textwidth}
%     \begin{lstlisting}[language=json,basicstyle=\tiny\tt]
% { "_id": "2",
%   "type": "Movie",
%   "title": "Truth",
%   "year": 2015,
%   "director_id": "345679",
%   "genre": "Drama",
%   "rating": {
%     "score": 6.8,
%     "voters": 12682
%   },
%   "criticisms":[
%     {
%       "journalist": "Jordi Costa",
%       "media": {
%         "name": "El Pais",
%         "url": "http://elpais.com/"
%       },
%       "color": "red"
%     },
%     {
%       "journalist": "Lou Lumenick",
%       "media": "New York Post",
%       "color": "green"
%     }
%   ]
% },
% {
%   "_id": "345679",
%   "name": "James Vanderbilt",
%   "type": "director",
%   "directed_movies": ["2"]
% }
%     \end{lstlisting}
%   \end{columns}
% \end{frame}


\begin{frame}[fragile,allowframebreaks]
  \frametitle{Conceptos de MongoDB}
  \begin{description}[abc]
  \item[Base de datos] En MongoDB, se pueden crear diferentes {\em bases de
      datos} en cada servidor. Las bases de datos son un conjunto de {\em
      colecciones}
  \item[Colección] Una colección es un conjunto de {\em
      documentos}, cada uno de ellos identificado por una {\bf clave}. Se
    puede ver como un {\bf diccionario} que relaciona {\em ID} \ra{} {\em
      documento}
  \item[Documento] Conjunto de pares {\em clave}, {\em valor} que puede
    tener una estructura anidada. Se suelen representar como valores JSON,
    aunque internamente se representan eficientemente como BSON
  \end{description}

  \framebreak

\begin{lstlisting}[language=json,basicstyle=\tiny\tt]
{
  "_id": "2",
  "type": "Movie",
  "title": "Truth",
  "year": 2015,
  "director_id": "345679",
  "genre": "Drama",
  "rating": {
    "score": 6.8,
    "voters": 12682
  },
  "criticisms":[
    {
      "journalist": "Jordi Costa",
      "media": {
        "name": "El Pais",
        "url": "http://elpais.com/"
      },
      "color": "red"
    },
    {
      "journalist": "Lou Lumenick",
      "media": "New York Post",
      "color": "green"
    }
  ]
}
\end{lstlisting}

  \framebreak

  \begin{description}[abc]
  \item[Consultas] Posee un API para consultas sencillas con un lenguaje
    propio (no SQL)
  \item[Distribución] Permite {\bf distribuir} el contenido de las tablas
    entre diferentes {\bfseries\itshape Grupos de Réplicas}, que además
    permiten la {\bf tolerancia a fallos}
  \item[Procesamiento/Consultas complejas] El procesamiento y las consultas
    complejas se realizan usando el API de Map-Reduce o el de Agregación.
    Estos APIs permiten explotar la {\bf distribución y paralelismo}
  \end{description}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Conexión}
  \framesubtitle{Usando el lenguaje Python}
\begin{lstlisting}[language=python,basicstyle=\tt]
import pymongo
from pymongo import MongoClient

client = MongoClient("localhost", 27017)
\end{lstlisting}

\begin{lstlisting}[language=python]
>>> MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Creación de la base de datos ``{\tt centic18}''}
\begin{lstlisting}[language=python,basicstyle=\tt]
db = client.centic18
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Creación de la colección ``{\tt productos}''}
\begin{lstlisting}[language=python,basicstyle=\tt]
productos = db.productos
\end{lstlisting}
\begin{lstlisting}[language=python]
>>> Collection(Database(MongoClient(host=['localhost:27017'], document_class=dict, tz_aware=False, connect=True), 'centic18'), 'productos')
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Métodos de inserción y actualización}
  MongoDB ofrece métodos para inserción y actualización:
    \begin{itemize}
    \item {\tt insert\_one()}, {\tt insert\_many()} (batch)
    \item {\tt update\_one()} -- Permite actualizar un objeto con nuevos
      campos
    \item {\tt update\_many()} -- Permite poner nuevos valores calculados a
      un conjunto de objetos
    \end{itemize}
\end{frame}


\begin{frame}[fragile,fragile,allowframebreaks]
  \frametitle{Inserción de productos}
\begin{lstlisting}[language=python,basicstyle=\tt]
productos.insert_one(
{
    'nombre': 'Samsung XX40',
    'descripción' : 'Televisión Samsung, 40"...',
    'precio' : '600',
    'fabricante': 'Samsung',
    'stock': 20,
    'tags': ['tv', '40"', 'lcd', 'hdmi', 'smart-tv']
})
\end{lstlisting}

\framebreak

\begin{lstlisting}[language=python,basicstyle=\tt,escapechar=@]
productos.insert_one(
    {'nombre': 'LG T42',
     'descripción' : 'Televisión LG 42"',
     'precio' : 655,
     'fabricante': "LG",
     'stock': 10,
     @\color{red}{'tags'}@ : ['tv', '42"', 'led', 'hdmi', 'smart-tv']
    })
\end{lstlisting}

\framebreak

\begin{itemize}
\item El ID se le asigna automáticamente
\item O bien se puede asignar a mano añadiendo un campo especial ``{\tt
    \_id}''
\item Los {\tt tags}, si bien son simulables con tecnologías relacionales,
  aquí ofrecen mucha flexibilidad
\item Como se verá, la búsqueda se puede hacer por {\em tag\/}
\end{itemize}
\end{frame}


\begin{frame}[fragile,allowframebreaks]
  \frametitle{Métodos de búsqueda sencilla}
  \begin{itemize}
  \item El método de búsqueda principal es {\tt find()}, que tiene muchas
    opciones
  \item Existe también una variante {\tt find\_one()}, que busca sólo un
    elemento (si existe)
  \item En general permite especificar:

    \begin{itemize}
    \item El filtro de búsqueda
    \item Ordenación de resultados por algún campo
    \item Proyección de los campos mostrados en el resultado
    \item Número de resultados máximo ({\em limit\/})
    \item Número de elementos iniciales a ignorar ({\em skip\/})
    \item El tamaño del {\em batch}
    \end{itemize}

\framebreak

\item Proyección:
\begin{lstlisting}
db.productos.find({<criterio>},
        {"fabricante" : 1, "stock" : 1})
// =>
[{'_id': ObjectId('5b1d09b3b3d977001bc53e03'),
  'fabricante': 'Samsung',
  'stock': 20},
 {'_id': ObjectId('5b1d09beb3d977001bc53e04'),
  'fabricante': 'LG',
  'stock': 10}]
\end{lstlisting}

  \framebreak

\item Se pueden utilizar condicionantes para la búsqueda:
\begin{lstlisting}
db.productos.find({"stock" :
  {"$gt" : 10, "$lte" : 30}})

db.productos.find({ "$or" :
     [ {"fabricante" : "Samsung" },
       {"fabricante" : "LG"} ] })
\end{lstlisting}

\item Búsqueda con {\em tags\/} seleccionadas:

\begin{lstlisting}[language=python]
db.productos.find({"tags" :
    {"$elemMatch" :
        {'$in' : ['tv', 'smart-tv']}}})
\end{lstlisting}

  \end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{Ups, ¡valoraciones de usuarios!}
\begin{itemize}
\item En un momento dado podemos querer añadir las valoraciones de usuarios
\item En un entorno relacional hubiera obligado a {\bf crear tablas}, {\bf
    cambiar cosultas}, {\bf realizar JOINs}, etc.
\item En el caso de MongoDB:
  \begin{itemize}
  \item El ID del objeto se ha obtenido al mostrarlo
  \item El {\tt user} es del {\em login\/} del usuario
  \end{itemize}

\begin{lstlisting}[language=python]
db.productos.update_one(
 {'_id': ObjectId('5b1d09b3b3d977001bc53e03')},
 {'$push' : {'valoraciones' :
   {'user': 'Pepe', 'estrellas' : 3.5, 'comment': 'bah'}}})
\end{lstlisting}

\framebreak

% \begin{lstlisting}[language=python]
% db.productos.update_one(
%  {'_id': ObjectId('5b1d09b3b3d977001bc53e03')},
%  {'$push' : {'valoraciones' :
%    {'user': 'Diego', 'estrellas' : 5, 'comment': 'Like!'}}})
% \end{lstlisting}

\item No hace falta definir de antemano el campo ``{\tt valoraciones}''
\item Las modificaciones sobre el objeto producto son {\bf atómicas}
  \begin{itemize}
  \item No hay necesidad de {\bf transacciones ACID}
  \end{itemize}
\item Todos los campos se recuperan {\bf en la consulta}
\end{itemize}
\end{frame}

%% TODO: Update many

% \begin{frame}
%   \frametitle{Índices, {\tt explain()}}
% \begin{itemize}
% \item La llamada {\tt .explain()} a cualquier búsqueda muestra el plan
%   de ejecución
% \item Al igual que las BBDD relacionales, muestra si se están utilizando
%   índices
% \item Se puede crear un índice si la búsqueda por ese campo va a ser
%   crítica:
%   \begin{itemize}
%   \item {\tt ASCENDING}
%   \item {\tt DESCENDING}
%   \item {\tt HASHED}
%   \item Geoespaciales
%   \end{itemize}
% \end{itemize}
% \end{frame}


\begin{frame}[allowframebreaks,fragile]
\frametitle{Map-Reduce}

 {\bf Map-Reduce} es el principal mecanismo de búsqueda y transformación en
 BBDD NoSQL. Tiene su origen en {\bf lenguajes funcionales}:
  \begin{block}{{\tt map()}}
    Ejecuta una misma función sobre todos los elementos de un conjunto
  \end{block}
  \begin{block}{{\tt reduce()}}
    Procesa un conjunto de valores para producir un valor de salida
  \end{block}

\framebreak

Map-Reduce combina ambas operaciones:
\begin{itemize}
\item Una misma operación {\tt map()} a cada dato residente en un nodo se
  realiza de forma {\bf paralela en todos los nodos}
\item Con los resultados parciales de cada nodo, una función {\tt reduce()}
  genera un resultado (o conjunto de resultados) final
\item Hay un proceso intermedio de {\em shuffle} para agrupar valores
  relacionados antes del {\tt reduce()}
\item Resultados parciales en el mismo nodo (localidad) $\Rightarrow$
  procesamientos {\bf en cadena}
\end{itemize}

\end{frame}

% \begin{frame}
% \frametitle{Map-Reduce en entornos Big Data}
% \begin{itemize}
%   \item Entrada \ra{} siempre pares $<key,value>$

%   \item {\tt map()} produce otro conjunto de valores
%     $\{<key1,value1>,<key2,value2>,...\}$

% \item {\em Shuffle} agrupa los valores con la misma clave:
% \begin{displaymath}
% \{<key1,\{val1,val3,...\}>,<key2,\{val2,val4,...\}>,...\}
% \end{displaymath}

% \item {\tt reduce()} procesa cada lista de valores con la misma clave, y
%   produce otros elementos $<key',value'>$

% \item Hay procesamientos difíciles de expresar en Map-Reduce $\Rightarrow$
%   varias operaciones M/R {\bf en cadena}
%   \end{itemize}

% \end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{Map-Reduce}
  \framesubtitle{NoSQL Distilled. Sadalage, Fowler, Addison-Wesley, 2012}
  \includegraphics[width=\textwidth]{img/mapreduce1}
  \framebreak
  \includegraphics[width=\textwidth]{img/mapreduce2}
\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{Map-Reduce como generalización de consultas}

  {\bf Ejemplo}: Imagínese un biólogo marino que hace anotaciones de cada
  animal que ve en el océano, y quiere saber cuántos tiburones ha visto por
  mes:

  \begin{lstlisting}[language=SQL]
SELECT MONTH(observation_timestamp) AS observation_month,
       sum(num_animals) AS total_animals
FROM observations
WHERE family = 'Sharks'
GROUP BY observation_month;
\end{lstlisting}

  \framebreak

MongoDB con el API de MapReduce:
\begin{lstlisting}[language=Javascript,basicstyle=\footnotesize\tt]
db.observations.mapReduce(
  function map() {
    var year = this.observationTimestamp.getFullYear();
    var month = this.observationTimestamp.getMonth() + 1;
    emit(year + "-" + month, this.numAnimals);
  },
  function reduce(key, values) {
    return Array.sum(values);
  },
  {
    query: { family: "Sharks" },
    out: "monthlySharkReport"
  });
\end{lstlisting}

% MongoDB ofrece además un API alternativo para funciones de agregación:

% \begin{lstlisting}[language=Javascript,basicstyle=\footnotesize\tt]
% db.observations.aggregate([
%   { $match: { family: "Sharks" } },
%   { $group: {
%     _id: {
%        year: { $year: "$observationTimestamp" },
%        month: { $month: "$observationTimestamp" }
%     },
%     totalAnimals: { $sum: "$numAnimals" }
%   }
%   }
% ]);
% \end{lstlisting}

\end{frame}

\begin{frame}[plain]
  \includegraphics[width=\textwidth]{img/sql-to-mongodb}
\end{frame}


\begin{frame}
  \frametitle{Map-Reduce}
  \centering\includegraphics[height=.85\textheight]{img/mongo-map-reduce}
\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{Map-Reduce}
%   \begin{itemize}
%   \item La función {\tt map\_reduce()} de cada colección permite ejecutar
%     procesamientos que guardan los resultados en otra colección o la
%     devuelven en vivo
%   \item Como el código se ejecuta dentro del motor de la base de datos, hay
%     que enviarle el código en Javascript
%   \item Por ejemplo, cálculo de la valoración media de productos por
%     fabricante:

%   \end{itemize}

% \framebreak
\begin{lstlisting}[language=Python]
from bson.code import Code
map = Code(
'''function () {
     obj = this
     if ('valoraciones' in this)
         this.valoraciones.forEach(function (v) {
             emit(obj.fabricante, v.estrellas);
         })
   }''')
reduce = Code(
'''function (key, values) {
        return Array.sum(values) / values.length;
   }''')
results = db.productos.map_reduce(map, reduce, "valoración_media")
\end{lstlisting}

\framebreak

La colección {\tt valoración\_media} tendrá valores:

\begin{lstlisting}[language=Python]
[{'_id': 'Samsung', 'value': 4.25},
 {'_id': 'LG', 'value': 4},
 ...
]
\end{lstlisting}

\end{frame}

\begin{frame}
  \frametitle{Framework de agregación}
  \centering\includegraphics[height=.85\textheight]{img/mongo-aggregation}
\end{frame}

% \begin{frame}[fragile,allowframebreaks]
%   \frametitle{Framework de agregación}

% \begin{itemize}
% \item El {\em framework de agregación} ofrece un API alternativo a
%   Map-Reduce que también explota la {\bf distribución}
% \item Especificaciones basadas en {\bfseries\itshape pipelines}
% \item Las {\em pipelines\/} se ejecutan en orden, y existen de varios
%   tipos:
%   \begin{itemize}
%   \item Proyección y cambio de campos: \verb|$project|, \verb|$addFields|,
%     \verb|$redact|, etc.
%   \item Agrupamiento y expansión: \verb|$group|, \verb|$unwind|
%   \item Limitación: \verb|$limit|, \verb|$sample|, \verb|$skip|
%   \item JOIN: \verb|$lookup|
%   \item Filtros: \verb|$match|
%   \item Ordenación: \verb|$sort|
%   \end{itemize}
% \end{itemize}

% \begin{lstlisting}[language=python,basicstyle=\tt]
% db.collección.aggregate( [
%  <acción1>,
%  <acción2>,
%  ...,
%  <acciónN>])
% \end{lstlisting}

% \framebreak

% Media de valoraciones por fabricante:

% \begin{lstlisting}[language=python]
% val_media = db.productos.aggregate( [
%  {'$project': {
%      'fabricante' : True,
%      'valoraciones' : True}
%  },
%  {'$unwind' : '$valoraciones' },
%  {'$group' : {
%      '_id' : '$fabricante',
%      'avg_val' :
%        {'$avg' : '$valoraciones.estrellas'}
%  }},
%  {'$sort' : { 'avg_val' : 1}}
%  ])
% \end{lstlisting}

% \framebreak

% Se pueden añadir etapas. En particular, por ejemplo, se puede {\bf filtrar}
% inicialmente añadiendo al principio:

% \begin{lstlisting}[language=python]
% {'$match': { 'nombre' : {'$regex': 'LG.*'}}}
% \end{lstlisting}

% La construcción
% \verb|$lookup| permite el acceso a otra (o a la misma) colección. Es
% equivalente a un {\bf JOIN}

% \framebreak

%   P. ej., imaginemos que existe la colección {\tt usuarios} y que tienen
%   ciudad. Agrupamos valoración por fabricante y por ciudad:

% \begin{lstlisting}[language=python,basicstyle=\scriptsize\tt]
% val_media = db.productos.aggregate( [
%  {'$project': { 'fabricante' : True,
%               'valoraciones' : True}},
%  {'$unwind' : '$valoraciones' },
%  {'$lookup' : {
%    "from": "usuarios",
%    "localField": "$valoraciones.user",
%    "foreignField": "_id",
%    "as": "user"} },
%  { "$unwind" : "$user" },
%  {'$group' : {
%      '_id' : [ '$fabricante', '$user.ciudad ],
%      'avg_val' :
%        {'$avg' : '$valoraciones.estrellas'} }},
%  {'$sort' : { 'avg_val' : 1}}
%  ])
% \end{lstlisting}

% \end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{BD Documentales: Casos de uso}
  \begin{itemize}
  \item {\em Drop-in Replacement\/}
    \begin{itemize}
    \item Todo lo que se puede hacer con SQL se puede hacer con
      Documentales
    \item La eficiencia (tiempo y espacio es similar)
    \item Ofrecen características de escalabilidad horizontal
    \end{itemize}
  \item Trabajo con datos...
    \begin{itemize}
    \item Cambiantes, externos, JSON, procedentes de APIs REST
    \end{itemize}
  \item Entorno {\bf ágil} (no hace falta esquema)

\framebreak

\item Flexibilidad en el modelo de datos
    \begin{itemize}
    \item Utilización de agregados
    \item Los ORMs también permiten usarlos
    \item Pero el código que generan a veces {\bf no es óptimo}
    \item Y {\bf crea deuda técnica con la implementación} (¿mantenimiento,
      evolución?, etc.)
    \end{itemize}
  \item Trabajo con {\bf datos geográficos} (GeoJSON, consultas por
    proximidad geográfica)
  \item {\bf Eficiencia} para ciertos tipos de cargas de trabajo (muchas
    actualizaciones)
  \end{itemize}
\end{frame}

\subsection{Bases de Datos Columnares}

\begin{frame}[allowframebreaks]
  \frametitle{Bases de Datos Columnares}
\begin{itemize}
\item Influenciadas por el artículo de Google de 2006 sobre
  BigTable\footnote{Chang, Fay; Dean, Jeffrey; Ghemawat, Sanjay; Hsieh,
    Wilson C; Wallach, Deborah A; Burrows, Michael ‘Mike’; Chandra, Tushar;
    Fikes, Andrew; Gruber, Robert E (2006), {\em Bigtable: A Distributed
      Storage System for Structured Data},
    (\href{http://research.google.com/archive/bigtable-osdi06.pdf}{PDF}),
    Google.}
\item En general, parecidos a las tablas SQL, salvo que cada fila puede:
  \begin{itemize}
  \item Tener un {\bf conjunto de columnas diferente}
\item Almacenar {\em series temporales} dentro de una misma fila (varias
  {\em versiones} de un mismo conjunto de columnas)
  \end{itemize}
\item Cada fila tiene un identificador y es un agregado de familias de
  columnas ({\em column family})
\item Cambian el modo de almacenamiento para favorecer ciertas aplicaciones
  (almacenamiento {\bf por columnas en vez de por filas})
\item Bases de datos: {\bf HBase}, {\bf Cassandra}, {\bf Vertica}, {\bf
    H-Store}
\end{itemize}
\end{frame}

\begin{frame}[plain]
\includegraphics[width=\textwidth]{img/column}
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{Introducción a HBase}
\begin{center}
  \includegraphics[width=.5\textwidth]{img/hbase_logo}
\end{center}
Base de datos {\em wide column store}
\begin{itemize}
\item Importante: Permite variabilidad en el número de columnas de cada
  fila
\item Crece en número de filas. También puede crecer en {\bf número de
    columnas} sin coste
\item Una dimensión más de diseño
\item También: Permite almacenar todos los valores antiguos para un dato
  ({\bf series temporales})
\end{itemize}

\framebreak

Diseñada para guardar cantidades de datos ingentes en clústers de
ordenadores. ``{\bf La base de datos de Hadoop}''
  \begin{itemize}
  \item HDFS para almacenar la base de datos de forma distribuida
  \item HDFS permite acceso secuencial eficiente y trabajos
    {\em batch\/}
  \item HBase implementa acceso {\em random access} muy rápido
  \item Map/Reduce para realizar búsquedas complejas y procesamiento sobre
    la BD
  \end{itemize}

\framebreak

 Tabla {\em hash\/} enorme, tolerancia a fallos y distribución
  automática y guiada
  \begin{itemize}
  \item La BD mantiene {\bf físicamente juntas} las claves ordenadas {\bf
      lexicográficamente}
  \item Es {\bf muy rápido} encontrar filas consecutivas
  \item Además, cada columna se almacena {\bf independientemente}
  \item El diseño correcto de la clave es {\color{red} crítico}
  \end{itemize}

\framebreak

 Operaciones muy rápidas:
  \begin{itemize}
  \item Operaciones CRUD ({\em Create}, {\em Read}, {\em Update}, {\em
      Delete}) rápidas sobre documentos identificados por una clave (se
    implementa alguna versión de árbol B+)
\item Búsqueda secuencial con filtrado, ya que las claves están ordenadas
\item Almacenamiento de un número ilimitado de {\bf versiones de los datos}
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{¿Cuándo usar HBase?}

  \begin{block}{}
    Necesidad de realizar cientos, miles de operaciones por segundo en
    TB/PB de datos...
  \end{block}

  \begin{block}{}
    ...con patrones de acceso bien conocidos de antemano y sin gran
    complejidad
  \end{block}

\end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{Tecnologías habilitadoras de HBase}
HBase sobre Hadoop (HDFS y Map-Reduce)
\begin{itemize}
\item Una {\bf tabla} está formada por un número de filas, identificadas
  por una clave
\item Cada tabla se divide en {\bf regiones} (por rangos de clave ordenada
  lexicográficamente) ({\bf partición horizontal})
\item Una instalación de HBase utiliza un conjunto de {\bfseries\itshape
    Region Servers}: nodos de computación con almacenamiento local (y
  conectados al clúster HDFS)

% \framebreak

% \item Cada grupo de columnas (llamado {\bfseries\itshape Column~Family\/})
%   se almacena en un {\bf Store} ({\bf partición vertical})
% \item El {\bf Store} tiene una parte en memoria ({\bf MemStore}) y,
%   opcionalmente, un almacenamiento en disco, ({\bf HFile})
% \item Los {\bf HFile} se distribuyen usando HDFS para lograr replicación y
%   tolerancia a fallos
\end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{HDFS}
% HDFS posee una arquitectura distribuida:
%     \begin{itemize}
%     \item {\bf NameNode} -- Almacena información sobre qué partes
%       ({\bfseries\itshape Chunks}) tiene cada fichero, y dónde están
%       almacenadas (y replicadas)
%     \item {\bf Secondary Namenode} -- Sustituto del {\bf NameNode} en caso
%       de fallo
%     \item {\bf DataNode}s -- Almacenan los {\em chunks\/} de cada fichero.
%       Cada {\em chunk} puede estar replicado un número de veces,
%       dependiendo de la configuración de HDFS
%     \item {\bf Zookeeper} -- Se encarga de mantener una consistencia de
%       {\em clúster} (saber qué nodos hay conectados y activos) y
%       sincronización de datos
%     \end{itemize}
  \includegraphics[width=\textwidth]{img/hdfs1}
\end{frame}

% \begin{frame}
%   \frametitle{Inciso: {\em Consistent Hashing}}
% \framesubtitle{\url{http://blog.carlosgaldino.com/consistent-hashing.html}}
%   \includegraphics[width=\textwidth]{img/consistent-hashing}
% \end{frame}

% \begin{frame}
%   \frametitle{Inciso: {\em Bloom Filters}}
% \includegraphics[width=\textwidth]{img/bloom_filter}
% \end{frame}

% \begin{frame}[allowframebreaks]
%   \frametitle{Formato de almacenamiento}
%   \begin{itemize}
%   \item El formato de HBase es de filas ({\em rows})
% \item Cada fila contiene un conjunto especificado de {\em familias de
%   columnas}
% \item  Cada familia puede incluir un número arbitrario de {\em columnas},
%   que puede cambiar por cada fila
% \item Para cada valor de columna se pueden guardar opcionalmente varios
%   valores anotados con un {\em timestamp} (histórico)
%   \end{itemize}
% \end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{Hbase Shell}
\framesubtitle{Comandos básicos CRUD}
\begin{itemize}
% \item Versión, estado:

% \begin{lstlisting}[language=ruby]
% hbase(main):002:0> version
% 1.1.3, r72bc50f5fafeb105b2139e42bbee3d61ca724989, Sat Jan 16 18:29:00 PST 2016
% hbase(main):001:0> status
% 3 servers, 0 dead, 0.3333 average load
% \end{lstlisting}

% \framebreak

\item Creación de tablas, especificando las {\em column families}
  iniciales:
\begin{lstlisting}[language=ruby]
hbase> create 'productos', 'd', 'val', 'tags'
0 row(s) in 1.3810 seconds
=> Hbase::Table - productos
\end{lstlisting}

\item Se crea la tabla {\tt productos} con tres familias de columnas,
  {\tt d}, que guardará los datos del producto, {\tt val}, que
  guardará las valoraciones de los usuarios, y {\tt tags}, que guardará los
  tags de los productos

\item Se puede insertar y consultar datos
\end{itemize}
\end{frame}


% \begin{frame}[fragile]
%   \frametitle{{\tt happybase}}
%   \begin{itemize}
% \item Hay varios paquetes para acceder a HBase
% \item Incluso podríamos haberlo implementado desde JRuby y el {\em shell\/}
%   de HBase
% \item Pero lo haremos desde Python ya que lo hemos usado en todo el curso,
%   usando la librería {\tt
%     happybase}\footnote{\url{https://happybase.readthedocs.io/en/latest/}.}
% \item Hace uso del protocolo remoto Thrift
% \item Instalada en la máquina virtual. Si no, para instalarla:
% \begin{lstlisting}[language=bash]
% $ pip install happybase
% \end{lstlisting}
% \item El API es sencillo, ya que HBase ofrece relativamente pocas
%   operaciones
% \end{itemize}
% \end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{Creación de la base de datos}
\begin{lstlisting}[language=python]
try:
    connection.create_table('productos',
    {
      'd': dict(max_versions=1),
      'val' : dict(max_versions=1,compression='GZ'),
      'tags' : dict(max_versions=1)
    })
except:
    print("Error creando database: productos")
    pass
\end{lstlisting}
\end{frame}

% \begin{frame}[allowframebreaks]
%   \frametitle{Opciones de creación de tablas}
% \begin{itemize}
% \item {\tt max\_versions} es por defecto 1, y se pueden especificar todas o
%   un número finito de ellas
% \item En el caso de la familia {\tt val}, aplicamos compresión, ya que la
%   familia puede albergar gran cantidad de texto
% \item Se crea una familia
% \item También se pueden añadir opciones para configurar el filtro Bloom,
%   con la opción {\tt bloom\_filter\_type}, aunque no las veremos

%  \framebreak

% \item {\tt bloom\_filter\_type} puede estar deshabilitado ({\tt NONE}), o
%   tomar dos valores:
%   \begin{description}[ROW]
%   \item[{\tt ROW}] Permite establecer rápidamente si una fila no existe
%     \begin{itemize}
%     \item Como hemos visto, HBase mantiene una estructura de árbol B+ para
%       encontrar las filas buscadas
%     \item Sin embargo, el árbol guarda rangos de claves, pero no si una
%       clave específica existe o no
%     \item Poniendo el valor {\tt ROW}, se crea un filtro Bloom que permite
%       descartar cuando una clave no está
%     \end{itemize}
% \framebreak
%   \item[{\tt ROWCOL}] Realiza también un filtro Bloom para describir si
%     una columna está en una fila concreta o no. Las columnas pueden ser
%     muchas. Además, se utiliza un fichero para cada familia de columnas.
%     Por lo tanto, si no se tiene este índice, se tienen que hacer muchas
%     comprobaciones para saber si una de las columnas a mostrar está en una
%     fila concreta o no. El filtro Bloom con valor {\tt ROWCOL} crea un
%     filtro Bloom para las columnas de cada fila
%   \end{description}
% \end{itemize}
% \end{frame}


\begin{frame}[fragile,allowframebreaks]
  \frametitle{Añadimos los datos}
Añadiremos ahora los productos:

\begin{lstlisting}[language=python]
productos.put(b'tv40-sxx40',
 {
   'd:nombre': 'Samsung XX40',
   'd:descripción' : 'Televisión Samsung, 40"...',
   'd:precio' : '600',
   'd:fabricante': 'Samsung',
   'd:stock': '20',
   'd:tags' : 'tv,40",lcd,hdmi,smart-tv'
 })
\end{lstlisting}

% \framebreak

% \begin{lstlisting}[language=python]
% productos.put(b'tv42-LGT42',{
%   'd:nombre': 'LG T42',
%   'd:descripción' : 'Televisión LG 42"',
%   'd:precio' : '655',
%   'd:fabricante': "LG",
%   'd:stock': '10',
%   'd:tags' : 'tv,42",led,hdmi,smart-tv'
%   })
% \end{lstlisting}

\framebreak
Obtención de filas:

\begin{lstlisting}[language=python]
productos.row(b'tv40-sxx40')
# ==>
{b'd:descripci\xc3\xb3n': b'Televisi\xc3\xb3n Samsung, 40"...',
 b'd:fabricante': b'Samsung',
 b'd:nombre': b'Samsung XX40',
 b'd:precio': b'600',
 b'd:stock': b'20',
 b'd:tags': b'tv,40",lcd,hdmi,smart-tv'}
\end{lstlisting}

\framebreak

\begin{itemize}
\item Varias consideraciones del código anterior:
  \begin{itemize}
  \item Al ser una tabla ordenada por clave, la elección de la clave es
    {\bf crucial}
  \item En nuestro caso incluye la categoría inicial del producto
    \begin{itemize}
    \item Obtener filas consecutivas es {\bf muy rápido}
    \item Por ejemplo, todas las televisiones se pueden obtener buscando
      '{\tt tv}'
    \end{itemize}
  \end{itemize}
\item Además de poder almacenar millones de filas, las filas pueden {\bf
    crecer tanto como se quiera también en columnas}
\item Esta estrategia se puede usar para almacenar relaciones {\bf
    maestro/detalle} de manera eficiente, ya que se obtiene en una sola
  consulta
\item Todos los datos relacionados se obtienen {\bf con un solo get}
\item La usaremos para los {\em tags}
\end{itemize}

\framebreak

\begin{lstlisting}[language=python]
productos.put(b'tv40-sxx40', {
 'tags:tv' : '',
 'tags:40"' : '',
 'tags:lcd' : '',
 'tags:hdmi' : '',
 'tags:smart-tv' : ''})
\end{lstlisting}

\begin{itemize}
\item Las columnas no tienen valor
\item Sólo se usan como marcador de búsqueda rápida
\end{itemize}

\framebreak

La búsqueda se realiza de forma muy rápida:

\begin{lstlisting}[language=python]
productos.scan('tv40',columns=['tags:hdmi'])
# ==>
# [(b'tv40-sxx40', {b'tags:hdmi': b''}),
#  (b'tv42-LGT42', {b'tags:hdmi': b''})]
\end{lstlisting}

% \framebreak

% \begin{itemize}
% \item De forma similar, las valoraciones se pueden modelar en HBase con
%   esta estrategia usando la familia de columnas {\tt val}
% \item Todas las opiniones se obtendrán con un {\tt get} ({\tt row})
% \item Las columnas que irán dentro de la familia las podemos ver en esta
%   tabla:
% \end{itemize}

% \framebreak
% %   {'user': 'Pepe', 'estrellas' : 3.5, 'comment': 'bah'}}})
% %   {'user': 'Diego', 'estrellas' : 5, 'comment': 'Like!'}}})

% \begin{center}
%   \begin{tabular}{ll}
%     \toprule
%     Columna  & Valor \\
%     \midrule
%     {\tt val:user\_Diego} & {\tt Diego}\\
%     {\tt val:estrellas\_Diego} & {\tt 5}\\
%     {\tt val:comment\_Diego} & {\tt Like!}\\
%     {\tt val:user\_Pepe} & {\tt Pepe}\\
%     {\tt val:estrellas\_Pepe} & {\tt 3.5}\\
%     {\tt val:comment\_Pepe} & {\tt bah}\\
%     \bottomrule
%   \end{tabular}
% \end{center}

\begin{alertblock}{}
  En cualquier caso, se debe huir de usar {\tt scan} \ra{} HBase está
  construido para accesos O(1)
\end{alertblock}
\end{frame}

\begin{frame}
  \frametitle{{\tt scan()} {\em vs}. {\tt get()}}
\centering\includegraphics[height=.8\paperheight]{img/drake}
\end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{Búsquedas y filtrado}
\begin{itemize}
\item Como se ha visto, el diseño de las tablas HBase tiene que ir
  orientado a la {\bf optimización de las lecturas}
\item {\bf Desnormalizar todo lo necesario}
\item {\bf Con un único acceso} se obtenga toda la información necesaria
\item Sin embargo, esto no es posible siempre:
  \begin{itemize}
  \item Por ejemplo, se tiene que procesar un conjunto de elementos no
    predeterminado
  \item Se quieren calcular resultados agregados semanales, diarios, etc.
  \end{itemize}

\framebreak

\item HBase \ra{} lenguaje de filtrado \ra{} el servidor filtre los
  resultados
\item Clientes Thrift remotos y desde el {\em shell}
\item Filtrado de cada región en paralelo
\item Escalabilidad horizontal con varios {\tt RegionServer}s
\item Aunque ofrece diversos mecanismos de filtrado, {\bf no todos son
    igual de eficientes}
\item De hecho, el principal problema es que hay mucha diferencia (hasta el
  punto de hacer algunos impracticables) si no se usan bien
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Búsquedas y filtrado}
  \includegraphics[width=\textwidth]{img/filter-region-server}
\end{frame}

% \begin{frame}[fragile,allowframebreaks]
%   \frametitle{Especificación de filtros}
% \begin{itemize}
% \item Los filtros se especifican como parte de la llamada {\tt scan}
% \item Hay dos niveles de filtrado:
%   \begin{itemize}
%   \item El referido a columnas, que se especifica con el parámetro {\tt
%       COLUMNS} en el {\em shell\/} y {\tt columns=} en {\tt happybase}:

% \begin{lstlisting}[language=ruby]
% scan 'tabla',{COLUMNS => ['c1', 'c2']}
% \end{lstlisting}

%   \item Los filtros completos:

% \begin{lstlisting}[language=ruby]
% scan 'tabla' , { FILTER => "Filtro" }
% \end{lstlisting}

% (y se pueden combinar ambos)
%   \end{itemize}

% \framebreak

% \item En las bibliotecas cliente como {\tt happybase} con un parámetro de
%   la función {\tt scan}:
% \begin{lstlisting}[language=Python]
% table.scan(filter="Filtro...")
% \end{lstlisting}

% %\framebreak
% % \item Ordenación de las consultas en cuanto a su velocidad de ejecución:
% %   \begin{enumerate}
% %   \item Consultas de orden constante, como {\tt get} con clave o un
% %     conjunto de columnas
% %   \item Consultas rápidas porque hacen uso de los filtros Bloom: Prefijos
% %     de claves, familias de columnas, prefijos de familias de columnas,
% %     \ldots
% %   \item Consultas más lentas, que requieren en algunos casos el
% %     recorrido de toda la tabla (a evitar): Búsqueda por un valor en
% %     concreto, búsqueda de expresiones regulares, etc.\\
% %     (Todavía se benefician del escaneo en paralelo de todas las
% %     regiones en RegionServers)
% %   \end{enumerate}
% \end{itemize}
% \end{frame}


% \begin{frame}[fragile,allowframebreaks]
%   \frametitle{Sintaxis de filtros}
%   \begin{itemize}
%   \item La sintaxis general de los filtros es:

% \begin{verbatim}
% Filtro (parámetro1, parámetro2,...)
% \end{verbatim}

%   \item Los filtros se pueden unir con expresiones complejas que incluyan
%     paréntesis y también {\tt AND}, {\tt OR}, {\tt SKIP} y {\tt WHILE}
%     \begin{itemize}
%     \item {\tt SKIP} especifica que se ignore la fila si falla el filtro
%       alguno de los pares columna/valor
%     \item {\tt WHILE} muestra todos los conjuntos columna/valor de cada
%       fila hasta que un conjunto no cumple el filtro
%     \end{itemize}

%   \item Se ofrecen también operaciones de comparación: \verb|<|, \verb|<=|,
%     \verb|=|, \verb|!=|, \verb|>=|, etc.

% \framebreak

%   \item Y un conjunto de ``comparadores'':

%     \begin{itemize}
%     \item {\em BinaryComparator} -- Comparador binario lexicográfico de
%       elementos. Se representa con ``{\tt binary}''
%     \item {\em BinaryPrefixComparator} -- Comaprador binario de prefijos.
%       Se representa con ``{\tt binaryprefix}''
%     \item {\em RegexStringComparator} -- Comparador de cadenas usando una
%       expresión regular: ``{\tt regexstring}''
%     \item {\em SubStringComparator} -- Comparador de subcadena: ``{\tt
%         substring}''
%     \end{itemize}

% \framebreak

%   \item El formato de especificación es:

% \begin{verbatim}
% comparador:valor
% \end{verbatim}

%     Por ejemplo:

%     \begin{itemize}
%     \item {\tt binary:abc}
%     \item {\tt binaryprefix:abc}
%     \item {\tt regexstring:ab*c*}
%     \item {\tt substring:def}
%     \end{itemize}

%   \end{itemize}
% \end{frame}

% \begin{frame}[fragile,allowframebreaks]
%   \frametitle{Filtros}

%   \begin{itemize}
%   \item {\tt KeyOnlyFilter} -- No acepta argumentos y retorna sólo las
%     claves de los pares clave/valor:

% \lstset{basicstyle=\tiny\tt}

% \begin{lstlisting}
% hbase> scan 'productos', {FILTER => "KeyOnlyFilter()"}
% ROW                   COLUMN+CELL
%  tv40-sxx40           column=d:descripci\xC3\xB3n, timestamp=1528713898063, valu
%                       e=
%  tv40-sxx40           column=d:fabricante, timestamp=1528713898063, value=
%  tv40-sxx40           column=d:nombre, timestamp=1528713898063, value=
%  tv40-sxx40           column=d:precio, timestamp=1528713898063, value=
%  tv40-sxx40           column=d:stock, timestamp=1528713898063, value=
%  tv40-sxx40           column=d:tags, timestamp=1528713898063, value=
%  tv40-sxx40           column=tags:40", timestamp=1528714029653, value=
%  tv40-sxx40           column=tags:hdmi, timestamp=1528714029653, value=
%  tv40-sxx40           column=tags:lcd, timestamp=1528714029653, value=
%  tv40-sxx40           column=tags:smart-tv, timestamp=1528714029653, value=
%  tv40-sxx40           column=tags:tv, timestamp=1528714029653, value=
% ...
% \end{lstlisting}

% \item {\tt FirstKeyOnlyFilter} -- Retorna sólo la primera clave de cada
%   fila

%   \framebreak

%   \item {\tt PrefixFilter} -- Prefijo de fila dado:

%     \begin{lstlisting}
% hbase> scan 'productos', {FILTER => "PrefixFilter('tv')"}
%  tv42-LGT42           column=d:descripci\xC3\xB3n, timestamp=1528713899887, valu
%                       e=Televisi\xC3\xB3n LG 42"
%  tv42-LGT42           column=d:fabricante, timestamp=1528713899887, value=LG
% ...
% 2 row(s) in 0.0490 seconds
% \end{lstlisting}

%   \item {\tt ColumnPrefixFilter} -- Prefijo de columna dado:

% \begin{lstlisting}
% hbase> scan 'productos', {FILTER => "ColumnPrefixFilter('42')"}
% ROW                   COLUMN+CELL
%  tv42-LGT42           column=tags:42", timestamp=1528714029661, value=
% 1 row(s) in 0.0150 seconds
% \end{lstlisting}

%     \framebreak

% \item {\tt MultipleColumnPrefixFilter} -- (lista)

% \item {\tt ColumnCountGetFilter} -- Retorna hasta el número $n$ de columnas
%   dado

% \item {\tt PageFilter} -- Permite paginación de resultados por clave de
%   fila

%   \framebreak

% \item {\tt RowFilter} -- Coge un operador de comparación y un comparador.
%   Si la fila encaja con la comparación, la fila entera si muestra:

% \begin{lstlisting}
% hbase> scan 'productos', {FILTER => "RowFilter(<,'binary:tv42')"}
% ROW                   COLUMN+CELL
%  tv40-sxx40           column=d:descripci\xC3\xB3n, timestamp=1528713898063, valu
%                       e=Televisi\xC3\xB3n Samsung, 40"...
%  tv40-sxx40           column=d:fabricante, timestamp=1528713898063, value=Samsun
%                       g
% ...
% 1 row(s) in 0.0490 seconds
% \end{lstlisting}

%   % MultipleColumnPrefixFilter
% % This filter takes a list of column prefixes. It returns key-values that are present in a column that starts with any of the specified column prefixes. Each of the column prefixes must be of the form: “qualifier”.

% % ColumnCountGetFilter
% % This filter takes one argument – a limit. It returns the first limit number of columns in the table.

% % PageFilter
% % This filter takes one argument – a page size. It returns page size number of rows from the table.

% % ColumnPaginationFilter
% % This filter takes two arguments – a limit and offset. It returns limit number of columns after offset number of columns. It does this for all the rows.

% % InclusiveStopFilter
% % This filter takes one argument – a row key on which to stop scanning. It
% % returns all key-values present in rows up to and including the specified
% % row.

% % TimeStampsFilter
% % This filter takes a list of timestamps. It returns those key-values whose timestamps matches any of the specified timestamps.

% % RowFilter
% % This filter takes a compare operator and a comparator. It compares each row key with the comparator using the compare operator and if the comparison returns true, it returns all the key-values in that row.

% \item {\tt FamilyFilter} -- Acepta un operador y un comparador. Muestra
%   todas las columnas de familias de las columnas que cumplen el filtro.
%   Puede ser rápido si se ha definido un filtro Bloom {\tt ROWCOL} para las
%   familias de columnas

% \item {\tt QualifierFilter} -- Acepta un operador y un comparador. Muestra
%   todas las columnas dentro de cualquier familia de columnas que cumplen el
%   filtro. De nuevo, con filtros {\tt ROWCOL} funciona mejor porque puede
%   eliminar muchas filas


% % Family Filter
% % This filter takes a compare operator and a comparator. It compares each column family name with the comparator using the compare operator and if the comparison returns true, it returns all the Cells in that column family.

% % QualifierFilter
% % This filter takes a compare operator and a comparator. It compares each qualifier name with the comparator using the compare operator and if the comparison returns true, it returns all the key-values in that column.

% \item {\tt ValueFilter} -- Acepta un operador y un comparador. Si algún
%   valor de algún par clave/valor coincide, se muestran todos los elementos
%   de la fila

% % ValueFilter
% % This filter takes a compare operator and a comparator. It compares each value with the comparator using the compare operator and if the comparison returns true, it returns that key-value.

% % DependentColumnFilter
% % This filter takes two arguments – a family and a qualifier. It tries to locate this column in each row and returns all key-values in that row that have the same timestamp. If the row doesn’t contain the specified column – none of the key-values in that row will be returned.
%   \framebreak

% \item {\tt SingleColumnValueFilter} -- Acepta una familia de columnas, un
%   calificador de columna, un operador de comparación y un comparador. Si la
%   columna no está o está y tiene el valor especificado, se lista toda la
%   fila

% \begin{lstlisting}
% hbase> scan 'productos', {FILTER => "SingleColumnValueFilter('d', 'fabricante', =,'binary:Samsung')"}
% ROW                   COLUMN+CELL
%  tv40-sxx40           column=d:descripci\xC3\xB3n, timestamp=1528713898063, valu
%                       e=Televisi\xC3\xB3n Samsung, 40"...
%  tv40-sxx40           column=d:fabricante, timestamp=1528713898063, value=Samsun
%                       g
%  tv40-sxx40           column=d:nombre, timestamp=1528713898063, value=Samsung XX
%                       40
% ...
% 1 row(s) in 0.0500 seconds
% \end{lstlisting}

% % SingleColumnValueFilter
% % This filter takes a column family, a qualifier, a compare operator and a comparator. If the specified column is not found – all the columns of that row will be emitted. If the column is found and the comparison with the comparator returns true, all the columns of the row will be emitted. If the condition fails, the row will not be emitted.

% % SingleColumnValueExcludeFilter
% % This filter takes the same arguments and behaves same as SingleColumnValueFilter – however, if the column is found and the condition passes, all the columns of the row will be emitted except for the tested column value.

% \item {\tt ColumnRangeFilter} -- Acepta dos valores de columna y dos
%   booleanos. Muestra las columnas que están entre los valores. Los
%   booleanos especifican si se incluyen los valores límite o no.

% % ColumnRangeFilter
% % This filter is used for selecting only those keys with columns that are between minColumn and maxColumn. It also takes two boolean variables to indicate whether to include the minColumn and maxColumn or not.

% \end{itemize}
% \end{frame}

% \begin{frame}
%   \frametitle{Resumen de filtros y características}
%   \includegraphics[width=\textwidth]{img/filterlist1}
% \end{frame}
% \begin{frame}
%   \frametitle{Resumen de filtros y características}
%   \begin{center}
%     \includegraphics[width=.8\textwidth]{img/filterlist2}
%   \end{center}
% \end{frame}
% \begin{frame}
%   \frametitle{Resumen de filtros y características}
%   \includegraphics[width=\textwidth]{img/filterlist3}
% \end{frame}

% \begin{frame}[fragile,allowframebreaks]
%   \frametitle{Filtros vs. {\tt get}}
%   \begin{itemize}
%   \item Por muy eficiente que se haga el filtrado, un {\tt scan} siempre va
%     a ser mucho más lento que obtener una fila con {\tt get}
%   \item P.ej (3580ms):
% \begin{lstlisting}
% hbase> scan 'wlinks', { COLUMNS => ['to:19'] }
% ...
%  Yilmar Mosquera      column=to:19, timestamp=1479230326585, value=
%  Yukiko Iwai          column=to:19, timestamp=1479230347810, value=
% 113 row(s) in 35.7690 seconds
% \end{lstlisting}

%     \framebreak

%   \item vs (18ms):
% \begin{lstlisting}
% hbase> get 'wlinks', '19', { COLUMNS => ['from'] }
% ...
%  from:Yilmar Mosquera timestamp=1479230326578, value=
%  from:Yukiko Iwai     timestamp=1479230347796, value=
% 113 row(s) in 0.1760 seconds
% \end{lstlisting}

%   \item También existe una especificación de fila de inicio y final que son
%     más eficientes que un filtro {\em Row Prefix}:

% \begin{lstlisting}
% hbase> scan 'wlinks', {STARTROW => '19', ENDROW => '20', COLUMNS => ['from'] }
% \end{lstlisting}

%     Y en {\tt happybase}:

% \begin{lstlisting}[language=Python]
% table.scan(row_start='19', row_stop='20', columns=['from'])
% \end{lstlisting}

%   \end{itemize}
% \end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{Columnares: Casos de uso}
  \begin{itemize}
  \item Almacenamiento masivo y Acceso aleatorio basado en clave
    \begin{itemize}
    \item Almacenamiento sencillo
    \item Distribución en conjunto de servidores escalable
    \item Tolerante a fallos
    \end{itemize}
  \item Procesamiento analítico
    \begin{itemize}
    \item El almacenamiento es por columnas, sólo se recuperan los datos
      que se usan
    \item (En SQL los bloques de datos contienen toda la fila)
    \end{itemize}
\framebreak
  \item Procesamiento de series temporales/Datos de IoT
    \begin{itemize}
    \item Cada celda puede guardar un histórico de datos
    \item Existen adaptaciones de HBase (como Accumulo o TSDB) que permiten
      almacenar y procesar eficientemente series temporales
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Bases de Datos de Grafos}

\begin{frame}[allowframebreaks]
  \frametitle{Bases de Datos de Grafos}
\vspace*{-1ex}
  \begin{itemize}
  \item Las bases de datos de grafos llevan el mecanismo {\em muchos a
      muchos} al extremo
  \item Datos en los que existen muchas relaciones entre sí y {\bf las
      relaciones} tienen un significado primordial
\item Las bases de datos de grafos se basan en la construcción y consulta
  de un grafo que consta de
  \begin{itemize}
  \item {\bf Vértices} también llamados {\em nodos} o {\em entidades}, y
  \item {\bf Aristas} ({\bfseries\itshape Edges}), también llamados {\em
      relaciones}
  \end{itemize}
\item Los grafos pueden capturar relaciones complejas entre
  entidades y ofrecen lenguajes de búsqueda, actualización y creación que
  permiten trabajar con subconjuntos del grafo
% \item Orígenes en las bases de datos de hechos (con lenguajes de consulta
%   lógicos (p. ej. {\em Datalog})
\item Origen en las bases de datos de hechos ({\em Datalog\/})
\item Ejemplos: {\bf FlockDB}, {\bf Neo4J}, {\bf OrientDB}
\end{itemize}
\end{frame}

\begin{frame}[plain]
\includegraphics[width=\textwidth]{img/graph}
\end{frame}

% \begin{frame}[fragile,plain]
% (Nota: Usa la sintaxis PostgreSQL para {\tt json})
% \begin{lstlisting}[language=SQL]
% CREATE TABLE vertices (
%   vertex_id integer PRIMARY KEY,
%   properties json
% );

% CREATE TABLE edges (
%   edge_id integer PRIMARY KEY,
%   tail_vertex integer REFERENCES vertices (vertex_id),
%   head_vertex integer REFERENCES vertices (vertex_id),
%   label text,
%   properties json
% );

% CREATE INDEX edges_tails ON edges (tail_vertex);
% CREATE INDEX edges_heads ON edges (head_vertex);
% \end{lstlisting}
% \end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{Ejemplo de datos y consulta en Neo4J}
\begin{block}{}
\begin{lstlisting}
CREATE
  (NAmerica:Location {name:'North America', type:'continent'}),
  (USA:Location {name:'United States', type:'country' }),
  (Idaho:Location {name:'Idaho', type:'state' }),

  (Lucy:Person {name:'Lucy' }),

  (Idaho)-[:WITHIN]->(USA)-[:WITHIN]->(NAmerica),
  (Lucy) -[:BORN_IN]-> (Idaho)
\end{lstlisting}
\end{block}

\framebreak

Y de consulta:
\begin{block}{}
\begin{lstlisting}
MATCH
(person) -[:BORN_IN]-> () -[:WITHIN*0..]-> (us:Location {name:'United States'}),
(person) -[:LIVES_IN]-> () -[:WITHIN*0..]-> (eu:Location {name:'Europe'})
RETURN person.name
\end{lstlisting}
\end{block}

(con esta consulta tan cercana al lenguaje natural, estamos buscando los
emigrantes de EEUU en Europa)

\end{frame}


\begin{frame}[allowframebreaks]
  \frametitle{Aplicabilidad de Grafos}
  \begin{itemize}
  \item Los grafos, conceptualmente, aparecen en casi cualquier dominio
  \item Además, su flexibilidad hace que se puedan aplicar de diferentes
    formas
  \item Por ejemplo, una relación de {\em follow\/} entre usuarios:

    \begin{center}
      \includegraphics[width=.4\textwidth]{img/graph1}
    \end{center}
  \end{itemize}

    \begin{columns}
      \begin{column}{.5\textwidth}
        \begin{itemize}
      \item (nótese cómo {\bf Billy no ha seguido a Ruth}: las relaciones
        pueden ser unidireccionales o bidireccionales)

      \item Incluso se puede usar para guardar el conjunto de mensajes
        que se intercambian:
      \end{itemize}
    \end{column}
      \begin{column}{.5\textwidth}
        \begin{center}
          \includegraphics[width=.8\textwidth]{img/graph2}
        \end{center}
      \end{column}
    \end{columns}

\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{Flexibilidad y eficiencia}
\begin{itemize}
\item Las bases de datos basadas en grafos vienen a suplir dos carencias
  fundamentales:
  \begin{enumerate}
  \item La carencia expresiva del resto de paradigmas para expresar ciertos
    algoritmos que se expresan de forma natural en forma de grafos
  \item La eficiencia del tratamiento de estos procesos en grafos vs. otros
    paradigmas
  \end{enumerate}
% \item Como ejemplo, usemos una relación de amistad ({\em friend\/}) entre
%   usuarios de una red social
% \framebreak
% \item Una posible implementación relacional podría ser:
%   \begin{center}
%     \includegraphics[width=.7\textwidth]{img/friends_table}
%   \end{center}
% \framebreak
% \item Una consulta sencilla para obtener los amigos de Bob:
% \begin{lstlisting}[language=SQL]
% SELECT p1.Person
% FROM Person p1 JOIN PersonFriend
% ON PersonFriend.FriendID = p1.ID
% JOIN Person p2
% ON PersonFriend.PersonID = p2.ID
% WHERE p2.Person = 'Bob'
% \end{lstlisting}
% \item Es sencilla y no es computacionalmente muy compleja
% \item Como la relación de amistad no es recíproca siempre, a veces hay que
%   hacer la búsqueda inversa:
% \begin{lstlisting}[language=SQL]
% SELECT p1.Person
% FROM Person p1 JOIN PersonFriend
% ON PersonFriend.PersonID = p1.ID
% JOIN Person p2
% ON PersonFriend.FriendID = p2.ID
% WHERE p2.Person = 'Bob'
% \end{lstlisting}
% \item Esta consulta es más costosa que la anterior, porque se tienen que
%   recorrer todas las filas de {\tt PersonFriend}

% \item Pero ¿y si queremos ``{\bf los amigos de los amigos de Alice}''?
%   Ahora la consulta es mucho más compleja computacionalmente y también más
%   difícil de expresar en SQL:

% \begin{lstlisting}[language=SQL]
% SELECT p1.Person AS PERSON, p2.Person AS FRIEND_OF_FRIEND
% FROM PersonFriend pf1 JOIN Person p1
% ON pf1.PersonID = p1.ID
% JOIN PersonFriend pf2
% ON pf2.PersonID = pf1.FriendID
% JOIN Person p2
% ON pf2.FriendID = p2.ID
% WHERE p1.Person = 'Alice' AND pf2.FriendID <> p1.ID
% \end{lstlisting}

% \item Y sólo estamos bajando un nivel (amigos de amigos de Alice)
% \item Si tuviéramos que bajar otro nivel, se haría mucho más complejo por
%   todos los {\tt JOIN}

% \item En {\em Neo4j in Action\/}, Partner y Vukotic hicieron un experimento
%   con Neo4j y MySQL con esta tabla
% \item Buscaron amigos de amigos en diferentes niveles de profundidad
% \item En una red de 1 millón de personas cada uno con unos~50~amigos

%   \begin{small}
%     \begin{tabular}{llll}
%       \toprule
%       Prof.& Tiempos RDBMS & Tiempos Neo4j & Resultados\\
%       \midrule
%       2&0,016&0,01&\~{}2500\\
%       3&30,267&0,168&\~{}110.000\\
%       4&1543,505&1,359&\~{}600.000\\
%       5&(no termina)&2,132&\~{}800.000\\
%       \bottomrule
%     \end{tabular}
%   \end{small}
% \end{itemize}
%
% \begin{center}
%   \includegraphics[width=.78\textwidth]{img/graph3}
% \end{center}
%\end{frame}
\end{itemize}
\end{frame}

\subsubsection{Neo4j}

\begin{frame}[allowframebreaks]
  \frametitle{Introducción a Neo4j}
\centering\includegraphics[width=.4\textwidth]{img/neo4j-logo-2015}
  \begin{itemize}
\item Ofrece una base de datos de grafos con posibilidad de extenderse a
  varios ordenadores (aunque sólo uno de los ordenadores soporta escritura,
  replicación {\em master}-{\em slave})
\item Es compatible con el estándar Apache TinkerPop para la creación de
  grafos
\item Ofrece un lenguaje de creación y consulta de grafos: {\bf Cypher}
\item Ofrece también un {\em browser\/} web para lanzar consultas
\item También una consola que interpreta el lenguaje Cypher
\item Se puede usar desde Jupyter Notebook con la extensión {\tt
    ipython-cypher}
\item Finalmente, ofrece todos sus servicios a través de un API REST
  \end{itemize}
\end{frame}

\begin{frame}[allowframebreaks]
  \frametitle{Grafos en Neo4j}
  \begin{itemize}
  \item Los grafos en Neo4j son grafos etiquetados y con propiedades
  \item Están compuestos por {\bf nodos}, {\bf relaciones}, {\bf
      propiedades} y {\bf etiquetas}
\item Los nodos contienen propiedades, en la forma de pares clave-valor.
  Las claves son cadenas de caracteres y los valores pueden ser tipos
  primitivos o {\em arrays}
\item A los nodos se les puede etiquetar con una o más {\bfseries\itshape
    etiquetas}. Las etiquetas agrupan nodos por rol dentro del grafo
\item Las relaciones conectan nodos y estructuran el grafo. Una relación
  siempre tiene:
  \begin{itemize}
  \item una dirección,
  \item un nombre propio,
  \item un nodo de inicio y otro de fin
  \item un conjunto de propiedades
  \end{itemize}
\item Las propiedades permiten añadir información adicional al hacer el
  recorrido, como el peso asociado a atravesar ese enlace o la calidad del
  mismo
  \end{itemize}
\end{frame}

% \subsection{Browser de Neo4j}

% \begin{frame}[fragile]
%   \frametitle{Inicio de Neo4j en la máquina virtual}
%   \begin{itemize}
%   \item Hay que establecer el número de ficheros abierto a 40.000 (si no
%     está ya en la máquina virtual):
% \item En el fichero {\tt /etc/security/limits.conf}, añadir:
% \begin{verbatim}
% vagrant    soft    nofile    40000
% vagrant    hard    nofile    40000
% \end{lstlisting}
% \item Y ejecutar, en el directorio {\em home\/} de {\tt vagrant}:
% \begin{verbatim}
% $ ./start-neo4j.sh
% \end{lstlisting}

% \item Y la consola:

% \begin{verbatim}
% $ neo4j/bin/neo4j-shell
% \end{lstlisting}
%   \end{itemize}
% \end{frame}

% \begin{frame}
%   \frametitle{Browser}
%   \url{http://127.0.0.1:7474}. Usuario: neo4j, pass: neo4j.\\
%  Cambiar {\em password\/} a ``neo''
% \includegraphics[width=\textwidth]{img/neo4jbrowser}
% \end{frame}

\subsubsection{El lenguaje Cypher}

\begin{frame}[fragile]
  \frametitle{El lenguaje Cypher}
  \begin{itemize}
\item Lenguaje de especificación de búsquedas y modificaciones en el
  grafo
\item En las búsquedas y creaciones de nodos se especifican nodos con la
  sintaxis:
\begin{lstlisting}[language=cypher]
(nombre:Etiqueta {propiedad: valor, ... })
\end{lstlisting}

\item Las relaciones se especifican entre nodos de la siguiente manera,
  usando {\em ASCII art}:

\begin{lstlisting}[language=cypher]
(nodo_origen)-[:RELACIÓN]->(nodo_destino)
\end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{El lenguaje Cypher (ii)}
  \begin{itemize}
  \item Creación de nodos y enlaces: {\tt CREATE}
  \end{itemize}

\begin{lstlisting}[language=cypher]
CREATE (nodo1:Etiqueta1 { propX: valorX, ... } ),
       (nodo2:Etiqueta2 { propY: valorY, ... } ),
       ...
       (nodo1)-[:RELACIONADO_CON]->(nodo2)
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{En nuestro caso de productos}
\begin{lstlisting}[language=cypher]
CREATE (n:Producto
          {nombre: 'LG T42',
           descripción : 'Televisión LG 42"',
           precio : 655,
           fabricante: "LG",
           stock: 10,
           tags : 'tv,42",led,hdmi,smart-tv' })
\end{lstlisting}
\end{frame}


\begin{frame}[fragile,allowframebreaks]
  \frametitle{Consultas}
  \begin{itemize}
  \item Las consultas se realizan con el operador {\tt MATCH}
  \item Es un operador de consulta a través de ejemplos ({\em query by
      example})
\item Especifica nodos y propiedades como un ejemplo de los nodos y
  relaciones que se buscan
\item La sintaxis:

\begin{lstlisting}[language=cypher]
MATCH especificación, especificación, ...
[WHERE especificación]
RETURN [DISTINCT] nodos
\end{lstlisting}

\item {\tt MATCH} también se utiliza para seleccionar nodos para borrar
  ({\tt DELETE} o {\tt DETACH DELETE})

  \item Las consultas nombran nodos sobre los que se pueden buscar
    relaciones
\item Después, con {\tt RETURN} se especifica lo que devolver
\begin{lstlisting}[language=cypher]
MATCH (n:Producto) RETURN n
\end{lstlisting}
(retorna todos los productos)

\begin{lstlisting}[language=cypher]
MATCH (n { nombre: 'Diego' }) RETURN n.edad;
\end{lstlisting}

y también se puede especificar relaciones que se tienen que cumplir entre
los nodos para ser devueltos. Por ejemplo, todos los abuelos con sus
nietos:

\begin{lstlisting}[language=cypher]
MATCH (nieto), (abuelo),
   (nieto)-[:HIJO_DE]->()-[:HIJO_DE]->(abuelo)
 RETURN abuelo, nieto
\end{lstlisting}
o incluso:
\begin{lstlisting}[language=cypher]
MATCH (nieto)-[:HIJO_DE]->()-[:HIJO_DE]->(abuelo)
  RETURN abuelo, nieto
\end{lstlisting}

(nótense los nodos anónimos)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Creación de nodos a partir de otros}
  \begin{itemize}
  \item Un patrón común es la creación de nodos a partir de otros:
\item P. ej. apuntar los hijos de alguien:
\begin{lstlisting}[language=cypher]
MATCH (padre:Usuario { nombre: 'Diego' })
CREATE (violeta:Usuario {nombre:'Violeta'}),
       (martina:Usuario {nombre:'Martina'}),
       (violeta)-[:HIJO_DE]->(padre),
       (martina)-[:HIJO_DE]->(padre)
\end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Creación de relaciones}
  \begin{itemize}
  \item Para crear sólo relaciones y mezclar los nodos que ya existan se
    suele utilizar {\tt MERGE}
\item P. ej. si alguna de mis hijas existe, no se crea. Sólo se crean las
  que no existen
\begin{lstlisting}[language=cypher]
MATCH (padre:Usuario { nombre: 'Diego' })
MERGE (violeta:Usuario {nombre: 'Violeta'})
MERGE (martina:Usuario {nombre: 'Martina'})
MERGE (violeta)-[:HIJO_DE]->(padre)
MERGE (martina)-[:HIJO_DE]->(padre)
\end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Podemos modelar los {\em tags\/} como nodos}
\begin{lstlisting}[language=cypher]
MATCH (n:Producto {nombre: 'LG T42'})
   MERGE (a:Tag {nombre:'tv'})
   MERGE (a) -[:TAG]-> (n)
   MERGE (b:Tag {nombre:'42"'})
   MERGE (b) -[:TAG]-> (n)
   MERGE (c:Tag {nombre:'led'})
   MERGE (c) -[:TAG]-> (n)
   MERGE (d:Tag {nombre:'hdmi'})
   MERGE (d) -[:TAG]-> (n)
   MERGE (e:Tag {nombre:'smart-tv'})
   MERGE (e) -[:TAG]-> (n)
\end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Grafo:}
  \includegraphics[width=\textwidth]{img/neo4j1}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{También los usuarios y sus valoraciones}
\begin{lstlisting}[language=cypher]
CREATE (:Usuario {nombre: 'Diego'}),
       (:Usuario {nombre: 'Pepe'})
\end{lstlisting}

\begin{lstlisting}[language=cypher]
MATCH (u:Usuario {nombre: 'Diego'}),
      (p:Producto {nombre: 'Samsung XX40'})
MERGE (u)-[:VAL {estrellas:5, comment: "Like!"}]->(p)
\end{lstlisting}

\end{frame}

\begin{frame}
  \frametitle{Grafo:}
  \includegraphics[width=\textwidth]{img/neo4j2}
\end{frame}

\begin{frame}[fragile,allowframebreaks]
  \frametitle{Camino más corto entre dos usuarios}
  \begin{itemize}
  \item Puede servir para encontrar productos relacionados para sugerir a
    cada uno
  \item Se puede {\em aumentar} con información geográfica, información de
    amistad, etc.
  \end{itemize}
\begin{lstlisting}[language=cypher]
MATCH p=shortestPath( (u1:Usuario {nombre: "Diego"})-[*]-(u2:Usuario {nombre: "Pepe"}) ) RETURN p
\end{lstlisting}
  \begin{center}
    \includegraphics[height=.5\textheight]{img/neo4j3}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Grafos: Casos de uso}
  \begin{itemize}
  \item Tratamiento de información geográfica
    \begin{itemize}
    \item Planificación de rutas
    \item Optimización de rutas, combustible, etc.
    \end{itemize}
  \item Conexiones sociales
    \begin{itemize}
    \item Amistad, proximidad geográfica, grupo de edad
    \end{itemize}
  \item Integración de fuentes dispares de datos
    \begin{itemize}
    \item Integrar información geográfica con información meteorológica
    \end{itemize}
  \item Información fuertemente conectada, encontrar conexiones
    \begin{itemize}
    \item Papeles de Panamá...
    \end{itemize}
  \item {\bf Sistemas de recomendación}
  \end{itemize}
\end{frame}

% \tikzset{
% Above/.style={
%   midway,
%   above,
%   font=\Tiny,
%   text width=1cm,
%   align=center,
%   },
% Below/.style={
%   midway,
%   below,
%   font=\Tiny,
%   text width=1cm,
%   align=center
%   }
% }

% \begin{frame}
%   \frametitle{Decisión}
%   \begin{forest}
% for tree={
%   font=\Tiny,
%   grow'=east,
%   draw=cyan,
%   circle,
%   line width=0.2pt,
%   parent anchor=east,
%   child anchor=west,
%   edge={draw=cyan},
%   edge label={\Tiny\color{black}},
%   edge path={
%     \noexpand\path[\forestoption{edge}]
%       (!u.parent anchor) -- ([xshift=-1.6cm].child anchor) --
%       (.child anchor)\forestoption{edge label};
%   },
%   tier/.pgfmath=level(),
%   l sep=1.8cm,
% }
% [,rectangle, s sep=35pt,
%   [Herramienta impuesta,node options={fill=cyan,text width=1.2cm},edge label={node[Above]{¿Restricciones externas?}}
%   ]
%   [,edge label={node[Below]{Datos homogéneos}}
%     [SQL,node options={fill=cyan},edge
%     label={node[Above]{$\downarrow$ Relaciones}}]
%     [Grafos,node options={fill=cyan},edge
%     label={node[Above]{$\uparrow$ Relaciones}}]
%   ]
%   [,edge label={node[Below]{No Homogéneos}}
%     [SQL+Hacks,node options={fill=cyan},edge label={node[Above]{text}}]
%     [NoSQL,edge label={node[Below]{a longer text goes here}}]
%   ]
% ]
% \end{forest}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{Índices}
%   \begin{itemize}
%   \item Se pueden crear índices para búsquedas rápidas sobre atributos:
% \begin{lstlisting}[language=cypher]
% CREATE INDEX ON :Etiqueta(nombre)
% \end{lstlisting}
%   \end{itemize}
% \end{frame}

% \subsection{Arrays}

% \begin{frame}[allowframebreaks]
%   \frametitle{Bases de Datos basadas en Arrays}
%   \begin{itemize}
% \item Suelen presentarse como bases de datos que soportan SQL y añaden
%   operaciones para trabajar con conjuntos de datos especiales (arrays)
% \item Son bases de datos muy especializadas y no las trataremos aquí
% \item Utilizadas para tratamiento de grandes cantidades de datos de forma
%   estadística o de modelado y OLAP
% \item Soportan también datos geográficos, ya que pueden definir rangos
%   numéricos de una o varias dimensiones (2D para cálculos geográficos)
% \item Ejemplos: MonetDB, SciDB, rasdaman
%   \end{itemize}
% \end{frame}


% \section{Nuestro trabajo de investigación}

% \begin{frame}
%   \frametitle{Investigación en NoSQL Data Engineering}

%   \begin{itemize}
%   \item NoSQL Data Engineering
%   \item Toolbox MDE para gestionar BBDD NoSQL
%     \begin{itemize}
%     \item Inferencia del esquema
%     \item Tratamiento de la variabilidad de entidades (versiones)
%     \item Generación de código de mappers ODM, transformación de bases de
%       datos, etc.
%     \end{itemize}
%   \end{itemize}

%   \url{https://github.com/catedrasaes-umu/NoSQLDataEngineering}

% \centering  \includegraphics[height=3em]{img/logo_catedra}%
%   ~\includegraphics[height=3em]{img/logo_modelum}

% \end{frame}


% \begin{frame}[fragile]
%   \frametitle{BBDD NoSQL sin esquema explícito}
%   \framesubtitle{El esquema se encuentra implícito en los datos}
%   \begin{columns}
%     \begin{column}{0.5\textwidth}
% \begin{lstlisting}[language=json,basicstyle=\tiny\tt]
% {
%   "person_id": "123",
%   "type": "Person",
%   "lastName": "Rush",
%   "firstName": "Christopher",
%   º"address": "C/Gran Via, 13, Madrid"º
% },
% {
%   "person_id": "456",
%   "type": "Person",
%   "lastName": "England",
%   "firstName": "Wayne",
%   º"address": {
%     "street": "Av. Pinos, 24",
%     "city": "Murcia" }º
% },
% {
%   "person_id": "789",
%   "type": "Person",
%   "lastName": "Hoover",
%   "firstName": "Quinton",
%   "address": "Ronda Norte, 15, Murcia",
%   @"age": 35@
% }
%       \end{lstlisting}
%     \end{column}
%     \begin{column}{0.05\textwidth}
%       \begin{center}
%         \usetikzlibrary{decorations.pathreplacing}
%         \begin{tikzpicture}
%           \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=4pt},yshift=0pt]
%           (3.5,0.65) -- (3.5,6.5) node [black,midway,xshift=0.8cm] {\footnotesize};
%         \end{tikzpicture}
%       \end{center}
%     \end{column}
%     \begin{column}{0.45\textwidth}
%       \vspace{1cm}
%       \usetikzlibrary{arrows}
%       \begin{tikzpicture}
%         [node distance = .5\textwidth, auto, font=\normalsize,
%         every node/.style={node distance=.5\textwidth},
%         db/.style={cylinder, cylinder uses custom fill, cylinder end fill=yellow!50,
%         cylinder body fill=yellow!25, aspect=.3, shape border rotate=90, draw,
%         inner sep=5pt, text width=.3\textwidth, text height=.2\textwidth, text badly centered}]
%         \node [db] (nosqldb) {{\tiny Base de datos NoSQL}};
%         \path[draw=black,solid,line width=2mm,fill=black, preaction={-triangle 90,thin,draw,shorten >=-1mm}] (-3.5, 0) -- (-1.35, 0);
%       \end{tikzpicture}
%       \hspace{-2cm}
% \begin{small}
%       \begin{itemize}
%         \item Datos no uniformes
%         \item Existencia de distintas versiones
%       \end{itemize}
%     \end{small}
%   \end{column}
%   \end{columns}
% \end{frame}

% \begin{frame}
%   \frametitle{Proceso de inferencia NoSQLSchema}
%   \framesubtitle{Vista general de la arquitectura MDE empleada}
%   \centering
%   \begin{tikzpicture}
% [node distance = .1\textwidth, auto, font=\tiny,
% every node/.style={node distance=.25\textwidth},
% db/.style={cylinder, cylinder uses custom fill, cylinder end fill=yellow!50,
% cylinder body fill=yellow!25, aspect=.3, shape border rotate=90, draw,
% inner sep=5pt, text width=.1\textwidth, text badly centered},
% process/.style={ellipse, draw, fill=red!10, inner sep=5pt, text width=.12\textwidth, text badly centered},
% prod/.style={rectangle, draw, fill=green!10, inner sep=5pt, text width=.12\textwidth, text badly centered}]
% % Draw nodes
% \node [db] (nosqldb) {Base de datos\\NoSQL};
% \node [process, right of=nosqldb] (mapreduce) {Map-reduce};
% \node [prod, right of=mapreduce] (ov) {Colección\\de objetos JSON};
% \node [process, right of=ov] (jsoninject) {Transformación\\de objetos};
% \node [prod, below=.05\textwidth of jsoninject] (jm) {Colección\\de versiones};
% \node [process,below=.05\textwidth of jm] (schrev) {Proceso de\\ingeniería\\inversa};
% \node [prod, left of=schrev] (schmod) {Modelo\\NoSQLSchema};
% \node [process, left of=schmod] (appgen) {Generación de herramientas};
% \node [prod, left of=appgen,label=below:Herramientas] (apps) {$\Rightarrow$Visualización de esquemas\\\vspace{0.1cm}$\Rightarrow$Validación de datos\\\vspace{0.1cm}$\Rightarrow$Asistencia a la migración};

% \node [prod, below=.05\textwidth of schmod] (schemamm) {Metamodelo\\NoSQLSchema};
% %%%%%%%%%%%%%%%%
% % Draw the links between forces
% \path[-{Stealth},very thick]
% (nosqldb) edge (mapreduce)
% (mapreduce) edge (ov)
% (ov) edge (jsoninject)
% (jsoninject) edge (jm)
% (jm) edge (schrev)
% (schrev) edge (schmod)
% (schmod) edge (appgen)
% (appgen) edge (apps);

% \path[-{Stealth},dotted,very thick]
% (schmod) edge node[right] {<<conforma>>} (schemamm);
% \end{tikzpicture}
% \end{frame}

% \begin{frame}
%   \frametitle{Metamodelo NoSQLSchema}
%   \includegraphics[width=\textwidth]{img/mmnosql-schema}
% \end{frame}

% \begin{frame}
%   \frametitle{Visualizaciones (i)}
%   \includegraphics[width=\textwidth]{img/siriusglobalunion}
% \end{frame}

% \begin{frame}
%   \frametitle{Visualizaciones (ii)}
%   \includegraphics[width=\textwidth]{img/siriusglobal}
% \end{frame}

% \section{Referencias}

% \begin{frame}[fragile,allowframebreaks]
%   \frametitle{Referencias}

% \begin{thebibliography}{Paternostro, 2009}

% \setbeamertemplate{bibliography item}[book]
% \bibitem[Marz, 2015]{Marz2015}
% Nathan Marz, James Warren
% \newblock {\em Big Data: Principles and best
%   practices of scalable realtime data systems}
% \newblock Manning Publications,~2015

% \bibitem[Redmond, 2012]{Redmond2012}
% Eric Redmond, Jim R. Wilson
% \newblock {\em Seven Databases in Seven Weeks: A Guide to Modern Databases
%   and the NoSQL Movement}
% \newblock Pragmatic  Bookshelf,~2012

% \bibitem[Sadalage, 2013]{Sadalage2013}
% Pramod J. Saldage, Martin Fowler
% \newblock {\em NoSQL Distilled. A Brief Guide to the Emerging World of
%   Polyglot Persistence}
% \newblock Addison-Wesley,~2013

% \bibitem[Wilson, 2012]{Wilson2012}
% Jim R. Wilson, Eric Redmond
% \newblock {\em Seven Databases in Seven Weeks}

% \bibitem[Kleppmann, 2016]{Kleppmann2016}
% Kleppmann
% \newblock  \emph{Designing Data Intensive Applications}

% \bibitem[George, 2011]{George2011}
% Lars George
% \newblock {\em HBase, The Definitive Guide}

% \setbeamertemplate{bibliography item}[online]
% \bibitem[ApacheHBaseTeam, 2016]{ApacheHBaseTeam2016}
%   The Apache HBase Team
%   \newblock {\em Apache HBase Reference Guide}
%   \newblock \url{https://hbase.apache.org/book.html}

% \bibitem[HBaseCon, 2012a]{HBaseCon2012a}
%   Ian Varley
% \newblock Vídeo: {\em HBase Schema Design}
% \newblock
% \url{http://www.cloudera.com/content/dam/www/marketing/resources/events/hbase-con/video-hbasecon-2012-hbasecon-2012.png.landing.html}
% \newblock Transparencias:
% \url{http://es.slideshare.net/ivarley/hbase-schema-design-hbasecon-2012}

% \bibitem[George, 2013]{George2013}
%   Lars George
% \newblock {\em HBase Schema Design}
% \newblock \url{https://2013.nosql-matters.org/cgn/wp-content/uploads/2013/05/HBase-Schema-Design-NoSQL-Matters-April-2013.pdf}
% \newblock Otro vídeo: \url{https://vimeo.com/44715954}
% \newblock Sus transparencias: \url{http://2012.berlinbuzzwords.de/sites/2012.berlinbuzzwords.de/files/slides/hbase-lgeorge-bbuzz12.pdf}

% % \bibitem[Khurana, 2013]{khurana2013}
% % Amandeep Khurana, ;login:
% % \newblock {\em Introduction to HBase Schema Design}
% % \newblock \url{http://0b4af6cdc2f0c5998459-c0245c5c937c5dedcca3f1764ecc9b2f.r43.cf2.rackcdn.com/9353-login1210_khurana.pdf}

% % \bibitem[McDonald, 2015]{mcdonald2015}
% %   Carol McDonald
% %   \newblock {\em Guidelines for HBase Schema Design}
% %   \newblock \url{https://www.mapr.com/blog/guidelines-hbase-schema-design}

% \end{thebibliography}
% \end{frame}


\end{document}

%%% Local variables:
%%% mode: LaTeX
%%% TeX-master: t
%%% ispell-local-dictionary: "spanish"
%%% fill-column: 75
%%% TeX-parse-self: t
%%% TeX-auto-save: t
%%% End:
%%% vim: expandtab shiftwidth=2 tabstop=2
